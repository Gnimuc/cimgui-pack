// this file was auto-generated by wrapit v1.3.3
#include "Wrapper.h"

#include "jlImGuiTestEngine.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<ImGuiTestRunTask> : std::false_type { };
  template<> struct DefaultConstructible<ImGuiTestRunTask> : std::false_type { };
}

// Class generating the wrapper for type ImGuiTestRunTask
// signature to use in the veto file: ImGuiTestRunTask
struct JlImGuiTestRunTask: public Wrapper {

  JlImGuiTestRunTask(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type ImGuiTestRunTask (" __HERE__ ")");
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_engine.h:440:18
    jlcxx::TypeWrapper<ImGuiTestRunTask>  t = jlModule.add_type<ImGuiTestRunTask>("ImGuiTestRunTask");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<ImGuiTestRunTask>>(new jlcxx::TypeWrapper<ImGuiTestRunTask>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding Test methods  to provide read access to the field Test (" __HERE__ ")");
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_engine.h:442:25
    // signature to use in the veto list: ImGuiTestRunTask::Test
    t.method("Test", [](const ImGuiTestRunTask& a) -> ImGuiTest * { return a.Test; });
    t.method("Test", [](ImGuiTestRunTask& a) -> ImGuiTest * { return a.Test; });
    t.method("Test", [](const ImGuiTestRunTask* a) -> ImGuiTest * { return a->Test; });
    t.method("Test", [](ImGuiTestRunTask* a) -> ImGuiTest * { return a->Test; });
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_engine.h:442:25
    // signature to use in the veto list: ImGuiTestRunTask::Test
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Test! methods to provide write access to the field Test (" __HERE__ ")");
    t.method("Test!", [](ImGuiTestRunTask& a, ImGuiTest * val) -> ImGuiTest * { return a.Test = val; });

    DEBUG_MSG("Adding Test! methods to provide write access to the field Test (" __HERE__ ")");
    t.method("Test!", [](ImGuiTestRunTask* a, ImGuiTest * val) -> ImGuiTest * { return a->Test = val; });

    DEBUG_MSG("Adding RunFlags methods  to provide read access to the field RunFlags (" __HERE__ ")");
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_engine.h:443:25
    // signature to use in the veto list: ImGuiTestRunTask::RunFlags
    t.method("RunFlags", [](const ImGuiTestRunTask& a) -> ImGuiTestRunFlags { return a.RunFlags; });
    t.method("RunFlags", [](ImGuiTestRunTask& a) -> ImGuiTestRunFlags { return a.RunFlags; });
    t.method("RunFlags", [](const ImGuiTestRunTask* a) -> ImGuiTestRunFlags { return a->RunFlags; });
    t.method("RunFlags", [](ImGuiTestRunTask* a) -> ImGuiTestRunFlags { return a->RunFlags; });
    // defined in ./imgui_test_engine/imgui_test_engine/imgui_te_engine.h:443:25
    // signature to use in the veto list: ImGuiTestRunTask::RunFlags
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding RunFlags! methods to provide write access to the field RunFlags (" __HERE__ ")");
    t.method("RunFlags!", [](ImGuiTestRunTask& a, ImGuiTestRunFlags val) -> ImGuiTestRunFlags { return a.RunFlags = val; });

    DEBUG_MSG("Adding RunFlags! methods to provide write access to the field RunFlags (" __HERE__ ")");
    t.method("RunFlags!", [](ImGuiTestRunTask* a, ImGuiTestRunFlags val) -> ImGuiTestRunFlags { return a->RunFlags = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<ImGuiTestRunTask>> type_;
};
std::shared_ptr<Wrapper> newJlImGuiTestRunTask(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlImGuiTestRunTask(module));
}
